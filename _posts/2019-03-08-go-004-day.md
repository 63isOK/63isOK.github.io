# 介绍

新语言，吸收了其他语言中的一些思想，但也不是和其他语言完全一样，
所以需要了解一些细节的设计

## 格式

- 使用gofmt格式化代码
- 默认是tab缩进

## 注释

- /* */
- //
- godoc会从源码中收集文档
- 每个package都应该有包说明，如果有多个文件，只需要在一个文件中出现即可
- 每一个要暴露的对象，都需要添加注释
- 注释最好是一个完整的句子，主语应该是要描述的对象
- 带因式分解的声明，注释可以抽象一点

## 命名

- 包名应该小写，不带下划线，一般不用缩写，而用单个单词,不用驼峰写法
- 包被导入之后，包名就称为了内容访问器
- 包名和源码目录对应
- 尽量避免import . 除非测试
- abc包中的类型叫Writer，而不叫abcWriter
- 包暴露了多个类型时，构造方法应该是NewType1() NewType2()
- 包只暴露一个类型时，构造方法应该是New()
- 完备的文档说明比长名字的自解释要好一些,能短名字的就短一点，不行就用文档解释
- 变量的读取函数命名： var diy; 读Diy() 写SetDiy()，按这样的规则写,这是针对非暴露的，暴露的就无需多此一步
- 如果接口只包含一个方法，接口名应取 '方法er'
- 字符串转换方法命名为String，而不是ToString
- 单词名称命名使用峰驼记法，不要使用下划线

## 分号

- 源码中一般不需要出现;来表示语句结束，词法分析器会自动处理
- 分号在闭括号之前可以直接省略 eg: go func() { for { a = 1} }
- for循环子句中会出现分号，除此之外，一行中写多行语句也需要用到;
- 控制结构的左大括号{ 不能放在新行开头，只能放行未

遇到以下情况，词法分析器会自动添加;，判断依据是新行前的最后一个标记：
- 标识符 eg：int float64
- 基本字面量 eg：数值、字符串
- break continue fallthrough return ++ --

也就是说如果是一元运算符+-，或是逗号，都不会被认为是语句结束

## 控制结构

- if 和 switch可接受初始化语句
- 多了一个select选择
- for中不能使用++ -- 
- swith不会自动下溯(多个case使用一个执行体)，但可以将多个条件放在一个case中,逗号分割即可
- break Loop,和c++中的goto 标签类似
- continue 标签，只能在循环中使用

## 重新声明和再次赋值

```go
    f, err := os.open("1.txt")  // err是声明
    d, err := f.Stat()          // err是再次赋值，并非重新生成
```

什么情况下才是再次赋值，要满足以下条件：
- 本次声明和已声明在同一作用域 (不是同一作用域，就是新声明了)
- 赋的值要满足之前声明的类型
- 本次声明中至少有一个变量是新声明

## 函数

- 可以返回多个值
- 返回值可以命名，作用域在函数体内，会被初始化为零, 和在函数内创建变量相比，好处是多了一个0初始化
- defer延时执行,多用于资源的释放,可以有多个defer函数，先出现的后执行

## for

for可以支持数组、切片、信道、map和字符串，
字符串遍历时是解析utf-8，错误的unicode将占用一个字节，以u+fffd表示。rune就是一个unicode马点。

## type switch

接口.(type) 可以获取变量的实际类型，可以结合switch语句来做处理

## 数据

- 两中分配原语：new make
- 局部变量对应的数据在函数返回之后依然有效，这点和c不一样
- 数组赋值给数组，会复制其所有元素
- 数组当函数参数，传递的是数组副本，而不是指针
- 一般很少直接使用数组，一般使用切片来操作
- new 会将申请的内存置0，有时置0还不够，就需要用到构造函数。构造函数中可以使用复合字面量来简化。
- 复合字面量，会新申请内存的，特殊情况下复合字面量也可以不包含字段，new(Type)和&Type{} 是等价的
- 复合字面量要结合类型来看
- make 更多用于创建 切片 映射 信道，返回类型不是指针，也会初始化，不是置0操作，而是初始化其内部的数据结构
- make用于引用数据类型，new用于其他

## 数组 切片

切片是对数组的封装，提供的接口更加通用和强大，
除了矩阵变换需要明确维度，go中大部分都是使用切片，而非数组

二维数组有点特殊，特别是做图像处理时，切片分配时有两种方式:
- 独立分配每一次切片，适用于宽高会动态变化
- 只分配一个数组，切片与数组对应即可，适用于宽高固定的情况，构造效率更高
```go
    // 切片独立分配
    pic := make([][]uint8,y)
    for i: = range pic {
        pic[i] = make([]uint8, x)
    }

    // 数组一次分配，切片对应, 使用时还是使用切片代替数组
    pic := make([][]uint8, y)
    a := make([]uint8, x * y)
    for i := range pic {
        pic[i], a = a[:x], a[x:]  // 这个写法很特别，将循环变化的因子通过再次赋值的方式来表现
    }
```

## map

key-value

- key可以取很多值，但不能是切片
- map和切片类似，都是引用类型。意思是都是传址。
- map可以使用复合字面量构建，键值对使用逗号分割，键值之间使用冒号分割

```go
    var a = map[string]int {
        "a": 1,
        "b": 2,
    }
```

访问map中不存在的key，会返回类型对应的0值,
也可以用返回的第二个参数来判断key是否存在。

如果某个参数不关心，可以用空白标识符来表示： _ , ok := a["b"] // a是一个map， _ 

map中的删除，delete(key),即使key不存在，操作也是安全的，
这点比c++好用多了。

## 打印

- fmt.Printf
- fmt.Fprintf
- fmt.Sprintf 会返回一个新的字符串，而非填充给定的缓冲

- %v，用于打印通用格式，eg：非10进制会打印成10进制，数组、结构体、map都能打印
- %+v，还会把结构体上每个字段名打出来
- %#v，按go语言语法打印出来
- %q，遇到string或[]byte时，可打印出带引号的字符串，遇到整数或rune时，打印带单引号的
- %#q，会尽可能使用反引号
- %x，用于字符串 字节数组和整数，打印出很长的16进制字符串
- % x，中间带一个空格，打印出来的字节之间会插入空格
- %T，打印值的类型

自定义类型的默认格式，可通过String()string 方法来实现，
只需要注意String()方法中调用Sprintf时，别把类型作为string加入到格式化中，
解决方法是直接将类型实参显示转换成string。eg：
```go
    type MyString string
    func (m MyString)String()string{
        return fmt.Sprintf("MyString=%s", string(m))
        // return fmt.Sprintf("MyString=%s", m)  这种情况会导致无限递归
    }
```

func a(v ...interface{}){} // ...是告诉编译器 v是一个实参列表，省掉就是一个具体的接口对象了。
func a(v ...int) () {} // 表示实参列表是整形

## append()

func append(slice []T, elements ...T) []T 内置的追加函数

```go
    // 适用于切片，因为底层数组有可能改变，所以写法一般是 
    x := []int {1, 2, 3}
    y := []int {1, 2, 3}
    x = append(x, 4, 5, 6)

    // 切片追加切片
    x = append(x, y...) // 没有...会在编译时报类型错误
```

## 初始化

- 常量只能是数字 字符 字符串 bool。必须是编译器可以计算出的，运行期才能计算出值的不能是常量
- 枚举是通过const实现的，和c++类似都可以从0开始，自增，专门有个iota变量表示0,go叫这个是优雅
- 变量的值可以在运行期计算出来
- init() 每个源文件都可以有一个或多个，被称为初始化器，一些值的初始化就可以放在里面


- atoi 字符串转整形
- itoa 整形转字符串
- iota 常量0，也有其他名称：枚举创建器

特殊的init()函数：
- 所有变量都通过init()初始化，init函数才会被调用
- 导入的包初始化完了，才会调用init函数
- init()函数除了可以做初始化，还可以用作校验程序状态

## 方法

值接收者和指针接收者的区别：
- 值方法：方法中的变更不会影响到原有的接收者，go语言不允许这种错误，所以更多的是指针接收者
- 指针方法：会修改接收者的数据
- 值方法：可以通过指针和值调用
- 指针方法：只能通过指针调用，对此蹩脚的地方，go规定如果接收者可以寻址，go会自动按需添加取址操作

如果是指针方法，那么a.m()和&a.m()的效果是一样的，不写&,go编译器也会自动添加。

## 接口和其他类型

- 每种类型都可以实现多种接口

## 类型转换

类型转换有时是为了复用已有功能

## 接口转换 类型断言

interface.(type)是取具体的类型，interface.(string)是类型断言，判断是不是string

## 通用性






